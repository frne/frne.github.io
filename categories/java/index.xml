<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Franks.codes</title>
    <link>https://www.franks.codes/categories/java/</link>
    <description>Recent content in Java on Franks.codes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 18 Dec 2017 22:04:38 +0100</lastBuildDate>
    
	<atom:link href="https://www.franks.codes/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java Libs in Scala - A bit more Functional</title>
      <link>https://www.franks.codes/post/2017-12-18-using-java-libs-in-scala/</link>
      <pubDate>Mon, 18 Dec 2017 22:04:38 +0100</pubDate>
      
      <guid>https://www.franks.codes/post/2017-12-18-using-java-libs-in-scala/</guid>
      <description>Every Java library can be used in Scala, which is, for me, one of the good parts of the JVM world. But Java libs are mostly object-oriented and not functional, therefore full of side effects and somtimes &amp;ldquo;ugly&amp;rdquo; to use in Scala. But there are some approaches how to make Java libs (or their interfaces) more functional, so they can almost be used like a Scala lib.
Java 8 Type Conversion Many Java types like Map or List, but also functional types (Java 8) like Optional&amp;lt;T&amp;gt; have Scala pendents.</description>
    </item>
    
    <item>
      <title>Overcoming Checked Exceptions in Java Lambdas</title>
      <link>https://www.franks.codes/post/2017-09-06-overcoming-checked-exceptions-in-java-lambdas/</link>
      <pubDate>Wed, 06 Sep 2017 19:57:00 +0100</pubDate>
      
      <guid>https://www.franks.codes/post/2017-09-06-overcoming-checked-exceptions-in-java-lambdas/</guid>
      <description>In Java 8, the long awaited Lambda came to live, making it easy(-er) to do FP in Java. One problem I came across is, that most Java code throws checked exceptions which leads to IMHO ugly try/catch blocks in lambdas:
Function&amp;lt;A, B&amp;gt; fun = (a: A) -&amp;gt; { try { // some function call that trows checked exception$  return callFn(a); } catch (Exception e) { // return failure result  } }; The Good, the Bad and the Ugly A really simple, but also not really nice option is to wrap thrown exceptions into an unchecked one:</description>
    </item>
    
    <item>
      <title>Play Framework Actor Pooling with Guice (Java)</title>
      <link>https://www.franks.codes/post/2016-05-02-play-guice-actor-pooling/</link>
      <pubDate>Mon, 02 May 2016 23:11:01 +0200</pubDate>
      
      <guid>https://www.franks.codes/post/2016-05-02-play-guice-actor-pooling/</guid>
      <description>Working with the Play! Framework means working with Akka, intentionally or not. But working with Akka Actors can be tricky, especially when it comes to dependency injection. Play! 2.4 uses Google&amp;rsquo;s Guice for DI and of course it has the ability to also bind Actors so an ActorRef can be injected anywhere.
Single Actor DI Biding and injecting one single Actor is simple and well documented . Just bind it in a Module:</description>
    </item>
    
    <item>
      <title>Understanding Stemmers (Natural Language Processing)</title>
      <link>https://www.franks.codes/post/2015-07-23-understanding-stemmers-nlp/</link>
      <pubDate>Thu, 23 Jul 2015 18:05:12 +0200</pubDate>
      
      <guid>https://www.franks.codes/post/2015-07-23-understanding-stemmers-nlp/</guid>
      <description>I am interested in NLP and have already some experience with Apache Solr. It&amp;rsquo;s time to dig a little in-deep regarding stemmers. First of all, I was looking for a general definition of what a stemmer is, and I found this one, which IMHO is quite good:
 stemmer &amp;mdash; an algorithm for removing inflectional and derivational endings in order to reduce word forms to a common stem
 So what a stemmer does is nothing more, than converting words to their word stem.</description>
    </item>
    
  </channel>
</rss>